---
title: "Assignment 1"
author: "Jon Isaacson"
date: "10/1/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Part I Theory

## Problem 1
### Question
Let $X$ follow a binomial distribution with number of trials $n = 10$ and probability of success in each trial $\theta = 0.3$. Write an algorithm that requires only **one standard uniform random variable** to simulate one observation from the distribution of $X$ so that the efficiency for use of uniform random variables in simulating $X$ is 1:1.

### Solution

1. Simulate $u \sim U(0,1)$ 10 times
2. Compare the uniform random variable against $\theta$
$$
\left\{\begin{array}{cc}
u\leq\theta & y=1\\
u>\theta & y=0
\end{array}\right\}
$$
3. Calculate $y^*=\sum_{i=1}^{10}y_i$
4. Accept all $y^*$ as from $f(x)$

``` {r }
u<-runif(10)
theta<-0.3
y<-ifelse(u<=theta, 1, 0)
y.star<-sum(y)
y.star
```

## Problem 2
### Question
Consider the probability density function $f_X(x)=2x$ for random variable $X$ defined on $x \in [0,1]$. Two candidate methods, Algorithm 1 and Algorithm 2, to simulate $X$ are given below

Algorithm 1

1. Simulate $y^*\sim Unif(0,2)$
2. Simulate $u^*\sim Unif(0,1)$
3. if $y^*\leq2u^*$, accept $u^*$ as from $f_X(x)$, else reject and go to 1

Algorithm 2

1. Simulate $y^*\sim Unif(0,2)$
2. Simulate $w^*\sim Unif(\frac{y^*}{2},1)$
3. Accept **all** from $f_X(x)$

Assess whether Algorithm 1 and Algorithm 2 produce samples from the target distribution $f_X(x)$, supporting your answer clearly with a mathematical argument for each case.

### Solution
Both algorithms will produce samples from the target distribution. The difference is that algorithm 1 is less efficient than algorithm 2.

In algorithm 1, $u$ is a random variable that spans the entire set of the pdf $f_X(x)$. It's corresponding density has a range of $[0,2]$. Using this range as the simulation for $y*$, we can simulate random points anywhere in the box of $x\in[0,1$ and $y\in[0,2]$. Again the criterion is that a threshold must identify the maximum possible density for each corresponding point. The maximum value is identified with the pdf but substituting in the point(s) from the random variable $u$.

Algorithm 2 uses the inverse CDF transformation of the pdf to efficiently simulate $f(x)$. Geometrically instead of drawing a rectangular box around the pdf (like in algorithm 1), algorithm 2 transforms the box into a different shape---a triangle---and reduces the need to reject any possible values because they already fall within $f(x)$.

Because the pdf is simple, we can inverse the pdf as shown below.

$$f(x)=y=2x \rightarrow f^{-1}(x)=x=\frac{y}{2}$$

With the inverse pdf we can substitute $y$ for $w^*$ along the domain $[w^*,1]$.


## Problem 3
### Question
In general, we want to maximize the acceptance probability when sampling a given probability distribution using the rejection method. However, as we will later see in Markov chain Monte Carlo methods, when the idea of rejection is used in conjunction with complex computational algorithms, we may want to fix the probability of acceptance to optimize other aspects of an algorithm. Assume we want to sample the target random variable $X\sim Unif(-2,2)$ using a proposal random variable $Y \sim Unif(0, b); b > 0;$ and the symmetry of the uniform distribution. Find b so that the probability of acceptance is 0:4.

### Solution



## Problem 4
Assume X has probability density function $f_X(x)$; with

$$f_X(x)\propto K(e^{-x^2/2})\mathbf{I}_{\{[4,\infty)\}}$$
where $K$ is a constant and $\mathbf{I}_{A}$ is the indicator function that takes the value $1$ and $A$ and $0$ otherwise. In other words the support of $f_X(x)$ is $x\in[4,\infty)$.

### Question A 
Write an algorithm to simulate $f_X(x)$ using a **rejection method**.

### Solution A

### Question B
For your choice of proposal distribution, find the optimal value of parameter (of the proposal distribution) which maximizes the probability of acceptance.

### Solution B

## Problem 5
### Question
Show whether it is possible to use the rejection algorithm to simulate from the target distribution of a random variable whose natural logarithm is normally distributed, using a normal distribution as a proposal distribution.
### Solution

# Part II Practice

## Problem 6
For purposes of this problem you can use built-in random variable generating functions in R. For example, you can use rnorm to simulate normal random variables. In this problem we will computationally verify that in the context of linear regression we can obtain the Ordinary Least Squares estimates for the regression coefficients using a matrix decomposition method. We let
$$y_i=\beta_0+\beta_1x_{1i}+\beta_2x_{2i}+\epsilon_i,~~~i=1,2,...,n$$
where $y_i$ is the ith response at the ith predictor variables for $x_1$ and $x_2$ and $\epsilon_i$ are errors satisfying the Gauss-Markov conditions,

* $E(\epsilon_i)=0$, $Var(\epsilon_i=0)$, $\forall i$
* $Cov(\epsilon_i,\epsilon_j)$ $\forall (i,j)$

### Question A
Build a linear regression model and simulate a data set to work on. Let $n = 100,~\beta_1 = 3,~\beta_2 = 2$. In a classical linear regression model, the predictors $x_{1i}$ and $x_{2i}$ are fixed and for convenience we will fix these values by simulating them from $Unif(0 10)$ independently, and also simulate $\epsilon_i\sim Nor(\mu=0,\sigma=0.5)$ for $i=1,2,...,n $ Given values of predictors, regression coefficients, and errors, calculate the values of response variable $y_i$. We have simulated a data set from a linear regression model and know the true model since we set the values of parameters.

### Solution A
```{r}
set.seed(123)
source(file = "Function - Uniform Random Data Generator.R")
data<-unif.datagenerator(100, 2, 0, 10)
data.df<-data.frame(data)
data.df$Epsilon<-rnorm(100, 0, 0.5)
data.df$Y<-data.df$X1*3+data.df$X2*2+data.df$Epsilon
head(data.df)
```

### Problem B
Run `lm` function in R (see `?lm` in R) to perform a linear regression analysis (predictors $x_1, x_2$ and response $y$) and record $\hat\beta$ estimates from the R output.

### Solution B
```{r}
l.model<-lm(data=data.df, Y~X1+X2)
l.model$coefficients
```

### Question C
Write an R function that takes this data set as input and outputs $\hat\beta$ using svd function in R for Singular Value Decomposition.

### Solution C
```{r}
# svd.lm.coefficients<-function(data){}
```

### Question D
Compare estimates $\hat\beta$ from part (b) and (c).

### Solution D

## Problem 7
*Urn models* are probabilistic models that are basis for many real life discrete stochastic models. An urn model formulates a discrete data generating mechanism using various well-defined sampling schemes of balls from an urn.
  Consider the following urn model: There are $\alpha_W$ white balls, $\alpha_R$ red balls, and $\alpha_B$ blue balls in a well-mixed urn and no other balls. Draw a ball by simple random sampling. Observe its color and put it back to the urn together with another (new) ball of the same color. For example, if a red ball is drawn, then return that ball and an additional red ball to the urn before the second draw. Continue sampling this way and stop when n draws are made. This urn scheme is known as multivariate Pólya urn (basic Pólya urn has only two colored balls).
  We are interested in finding a method to simulate the random variable that captures
the number of balls of each color in n draws. For example if $n = 10$, a
realization of the random variable could be $(n_W = 4; n_R = 0; n_B = 6)$, $(n = n_W + n_R + n_B)$ Note that we can simulate this process directly by sampling balls
from an urn as described. However, this would be computationally inefficient if $n$
is large, we want to simulate samples for a number of $\alpha = (\alpha_W; \alpha_R; \alpha_B)$ vectors, or even generalize the model to non integer $\alpha$ (see part (b) below). An easier way is to find probability distributions associated with the described stochastic process and sample those distributions. 

### Question A
Write an R function that takes arguments as $(\alpha_W, \alpha_R, \alpha_B), n$, and returns a sample from this urn model using the random variable generation methods that we learned in class and any extrensions you can devise. As an example to illustrate that your program works use $ \alpha = (\alpha_W = 1, \alpha_R = 5 \alpha_B = 2)$ and $n = 100$.

### Solution A
```{r}

```

### Question B
Generalize your function to a model with $k$ types of balls, where the input is
a vector $\alpha = (\alpha_1, \alpha_2,..., \alpha_k)$ (and $n$), where $\alpha_i \in \mathbb{R}$; which means that $\alpha_i > 0$ does not need to be integer.

### Solution B